/**
 * GitHubToolProvider - Tool provider for GitHub repository operations
 *
 * Handles:
 * - Cloning repositories
 * - Running Claude Code to make changes
 * - Capturing diffs
 * - Creating pull requests
 */

import { ToolProvider } from './ToolProvider';
import type {
  ToolResult,
  ToolArtifact,
  ToolContext,
  LogCallback,
  SandboxInterface,
} from './ToolProvider';

export interface GitHubConfig {
  repoOwner: string;
  repoName: string;
  baseBranch: string;
  workBranch?: string;
  accessToken: string;
  anthropicApiKey: string;
}

interface PullRequestParams {
  title: string;
  body: string;
}

export class GitHubToolProvider extends ToolProvider {
  readonly type = 'github';
  private config: GitHubConfig;
  private workDir = '/workspace/repo';

  constructor(
    context: ToolContext,
    log: LogCallback,
    config: GitHubConfig
  ) {
    super(context, log);
    this.config = config;
  }

  async setup(sandbox: SandboxInterface): Promise<void> {
    this.log('info', `Cloning ${this.config.repoOwner}/${this.config.repoName}...`);

    await sandbox.mkdir('/workspace', { recursive: true });

    const repoUrl = `https://${this.config.accessToken}@github.com/${this.config.repoOwner}/${this.config.repoName}.git`;

    const cloneResult = await sandbox.exec(
      `git clone --depth 1 --branch ${this.config.baseBranch} ${repoUrl} ${this.workDir}`
    );

    if (cloneResult.exitCode !== 0) {
      throw new Error(`Failed to clone repository: ${cloneResult.stderr}`);
    }

    this.log('info', 'Repository cloned successfully');

    if (this.config.workBranch && this.config.workBranch !== this.config.baseBranch) {
      const checkoutResult = await sandbox.exec(
        `cd ${this.workDir} && git checkout -b ${this.config.workBranch}`
      );

      if (checkoutResult.exitCode !== 0) {
        throw new Error(`Failed to create branch: ${checkoutResult.stderr}`);
      }

      this.log('info', `Created branch: ${this.config.workBranch}`);
    }

    await sandbox.exec(`cd ${this.workDir} && git config user.email "weft-agent@example.com"`);
    await sandbox.exec(`cd ${this.workDir} && git config user.name "Weft Agent"`);
  }

  async execute(sandbox: SandboxInterface): Promise<ToolResult> {
    this.log('info', 'Starting Claude Code execution...');

    const taskFile = '/tmp/task-instructions.md';
    await sandbox.writeFile(taskFile, `
# Task Instructions

${this.context.instructions}

## Working Directory
${this.workDir}

## Guidelines
- Make minimal, focused changes
- Follow existing code style
- Add comments only where necessary
- Test changes if possible
`);

    try {
      const result = await sandbox.exec(
        `cd ${this.workDir} && ANTHROPIC_API_KEY="${this.config.anthropicApiKey}" claude --print "$(cat ${taskFile})"`
      );

      if (result.exitCode !== 0) {
        this.log('error', `Claude Code failed: ${result.stderr}`);
        return {
          success: false,
          summary: 'Claude Code execution failed',
          error: result.stderr || 'Unknown error',
        };
      }

      this.log('info', 'Claude Code execution completed');
    } catch (error) {
      this.log('error', `Claude Code error: ${error}`);
      return {
        success: false,
        summary: 'Claude Code execution failed',
        error: error instanceof Error ? error.message : 'Unknown error',
      };
    }

    await sandbox.exec(`cd ${this.workDir} && git add -A`);

    const statusResult = await sandbox.exec(`cd ${this.workDir} && git status --porcelain`);
    if (!statusResult.stdout.trim()) {
      this.log('info', 'No changes were made');
      return {
        success: true,
        summary: 'Task completed but no changes were made',
        artifacts: [],
      };
    }

    const diffResult = await sandbox.exec(`cd ${this.workDir} && git diff --cached`);
    const diff = diffResult.stdout;
    const artifacts = this.parseDiff(diff);

    const commitResult = await sandbox.exec(
      `cd ${this.workDir} && git commit -m "feat: ${this.context.instructions.slice(0, 50)}...

Generated by Weft Agent
Task ID: ${this.context.taskId}"`
    );

    if (commitResult.exitCode !== 0) {
      this.log('warn', `Failed to commit: ${commitResult.stderr}`);
    }

    this.log('info', `Generated ${artifacts.length} file changes`);

    return {
      success: true,
      summary: `Made ${artifacts.length} file changes`,
      artifacts: [
        {
          type: 'diff',
          name: 'Full Diff',
          content: diff,
          metadata: { fileCount: artifacts.length },
        },
        ...artifacts,
      ],
    };
  }

  async cleanup(sandbox: SandboxInterface): Promise<void> {
    this.log('info', 'Cleaning up sandbox...');

    try {
      await sandbox.rm('/workspace', { recursive: true });
    } catch {
      // Cleanup errors are non-fatal
    }

    this.log('info', 'Cleanup completed');
  }

  async action(
    sandbox: SandboxInterface,
    actionName: string,
    params: unknown
  ): Promise<unknown> {
    if (actionName === 'create_pr') {
      return this.createPullRequest(sandbox, params as PullRequestParams);
    }

    throw new Error(`Unknown action: ${actionName}`);
  }

  private async createPullRequest(
    sandbox: SandboxInterface,
    params: PullRequestParams
  ): Promise<{ prUrl: string }> {
    this.log('info', 'Creating pull request...');

    const branch = this.config.workBranch || `weft-task-${this.context.taskId}`;

    const pushResult = await sandbox.exec(
      `cd ${this.workDir} && git push origin ${branch}`
    );

    if (pushResult.exitCode !== 0) {
      throw new Error(`Failed to push branch: ${pushResult.stderr}`);
    }

    const response = await fetch(
      `https://api.github.com/repos/${this.config.repoOwner}/${this.config.repoName}/pulls`,
      {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.config.accessToken}`,
          'Accept': 'application/vnd.github.v3+json',
          'Content-Type': 'application/json',
          'User-Agent': 'Weft-App',
        },
        body: JSON.stringify({
          title: params.title,
          body: params.body,
          head: branch,
          base: this.config.baseBranch,
        }),
      }
    );

    if (!response.ok) {
      const error = await response.text();
      throw new Error(`Failed to create PR: ${error}`);
    }

    const pr = await response.json() as { html_url: string };
    this.log('info', `Pull request created: ${pr.html_url}`);

    return { prUrl: pr.html_url };
  }

  private parseDiff(diff: string): ToolArtifact[] {
    const artifacts: ToolArtifact[] = [];
    const fileRegex = /^diff --git a\/(.+) b\/(.+)$/gm;

    let match;
    const files: string[] = [];

    while ((match = fileRegex.exec(diff)) !== null) {
      files.push(match[2]);
    }

    const fileDiffs = diff.split(/(?=^diff --git)/m).filter(Boolean);

    for (let i = 0; i < fileDiffs.length; i++) {
      const fileDiff = fileDiffs[i];
      const fileName = files[i] || 'unknown';

      let action: 'added' | 'modified' | 'deleted' = 'modified';
      if (fileDiff.includes('new file mode')) {
        action = 'added';
      } else if (fileDiff.includes('deleted file mode')) {
        action = 'deleted';
      }

      artifacts.push({
        type: 'file_change',
        name: fileName,
        content: fileDiff,
        metadata: {
          path: fileName,
          action,
          lines: fileDiff.split('\n').length,
        },
      });
    }

    return artifacts;
  }
}
